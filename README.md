# Data Structures and Algorithms Interview Preparation

This repository contains a collection of common Data Structures and Algorithms problems frequently asked in technical interviews. Each section is organized by topic and includes detailed explanations, approaches, and solutions.

## Repository Structure

```
├── arrays/               # Array manipulation problems
├── dynamic-programming/ # Dynamic programming problems
├── hashing/             # Hash table and counting problems
├── linked-lists/        # Linked list operations and problems
├── recursion/           # Recursion and backtracking problems
├── sliding-window/      # Sliding window pattern problems
├── trees/               # Binary tree and BST problems
└── two-pointers/        # Two pointer technique problems
```

## Topics Covered

### 1. Arrays
- Kadane's Algorithm
- Maximum Frequency
- Array Manipulation

### 2. Recursion
- Fibonacci Series
- Palindrome Check
- Subset Generation
- Number Series

### 3. Hashing
- Character Frequency Count
- Number Frequency Count

### 4. Two Pointers
- Two Sum Problem (JavaScript & C#)
- Array Manipulation

### 5. Sliding Window
- Longest Substring without Repeating Characters
- Window Based Problems

### 6. Trees
- Tree Traversals (Inorder, Preorder, Postorder)
- Binary Tree Operations

## How to Use This Repository

1. **Choose a Topic**: Select the topic you want to practice
2. **Read the README**: Each folder has its own README explaining the concepts
3. **Study the Solution**: Review the provided solution and comments
4. **Test Your Understanding**: Run the code with different test cases
5. **Practice**: Try to implement the solution without looking at the code

## Time Complexity Guide

- O(1): Constant time
- O(log n): Logarithmic time
- O(n): Linear time
- O(n log n): Log-linear time
- O(n²): Quadratic time
- O(2ⁿ): Exponential time

## Best Practices

1. Understand the problem before coding
2. Consider edge cases
3. Think about time and space complexity
4. Test your solution with different inputs
5. Look for opportunities to optimize

## Contributing

Feel free to contribute by:
1. Adding new problems and solutions
2. Improving existing solutions
3. Adding better explanations
4. Including more test cases

## License

This project is available for personal use and learning purposes.